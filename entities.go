// Code generated by Fern. DO NOT EDIT.

package Lattice

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/anduril/lattice-sdk-go/v2/v3/internal"
	big "math/big"
	time "time"
)

var (
	entityEventRequestFieldSessionToken = big.NewInt(1 << 0)
	entityEventRequestFieldBatchSize    = big.NewInt(1 << 1)
)

type EntityEventRequest struct {
	// Long-poll session identifier. Leave empty to start a new polling session.
	SessionToken string `json:"sessionToken" url:"-"`
	// Maximum size of response batch. Defaults to 100. Must be between 1 and 2000 (inclusive).
	BatchSize *int `json:"batchSize,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *EntityEventRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetSessionToken sets the SessionToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityEventRequest) SetSessionToken(sessionToken string) {
	e.SessionToken = sessionToken
	e.require(entityEventRequestFieldSessionToken)
}

// SetBatchSize sets the BatchSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityEventRequest) SetBatchSize(batchSize *int) {
	e.BatchSize = batchSize
	e.require(entityEventRequestFieldBatchSize)
}

var (
	entityOverrideFieldEntity     = big.NewInt(1 << 0)
	entityOverrideFieldProvenance = big.NewInt(1 << 1)
)

type EntityOverride struct {
	// The entity containing the overridden fields. The service will extract the overridable fields from
	// the object and ignore all other fields.
	Entity *Entity `json:"entity,omitempty" url:"-"`
	// Additional information about the source of the override.
	Provenance *Provenance `json:"provenance,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *EntityOverride) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEntity sets the Entity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityOverride) SetEntity(entity *Entity) {
	e.Entity = entity
	e.require(entityOverrideFieldEntity)
}

// SetProvenance sets the Provenance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityOverride) SetProvenance(provenance *Provenance) {
	e.Provenance = provenance
	e.require(entityOverrideFieldProvenance)
}

var (
	entityStreamRequestFieldHeartbeatIntervalMs = big.NewInt(1 << 0)
	entityStreamRequestFieldPreExistingOnly     = big.NewInt(1 << 1)
	entityStreamRequestFieldComponentsToInclude = big.NewInt(1 << 2)
)

type EntityStreamRequest struct {
	// at what interval to send heartbeat events, defaults to 30s.
	HeartbeatIntervalMs *int `json:"heartbeatIntervalMS,omitempty" url:"-"`
	// only stream pre-existing entities in the environment and then close the connection, defaults to false.
	PreExistingOnly *bool `json:"preExistingOnly,omitempty" url:"-"`
	// list of components to include, leave empty to include all components.
	ComponentsToInclude []string `json:"componentsToInclude,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *EntityStreamRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetHeartbeatIntervalMs sets the HeartbeatIntervalMs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityStreamRequest) SetHeartbeatIntervalMs(heartbeatIntervalMs *int) {
	e.HeartbeatIntervalMs = heartbeatIntervalMs
	e.require(entityStreamRequestFieldHeartbeatIntervalMs)
}

// SetPreExistingOnly sets the PreExistingOnly field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityStreamRequest) SetPreExistingOnly(preExistingOnly *bool) {
	e.PreExistingOnly = preExistingOnly
	e.require(entityStreamRequestFieldPreExistingOnly)
}

// SetComponentsToInclude sets the ComponentsToInclude field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityStreamRequest) SetComponentsToInclude(componentsToInclude []string) {
	e.ComponentsToInclude = componentsToInclude
	e.require(entityStreamRequestFieldComponentsToInclude)
}

// Event representing some type of entity change.
var (
	entityEventFieldEventType = big.NewInt(1 << 0)
	entityEventFieldTime      = big.NewInt(1 << 1)
	entityEventFieldEntity    = big.NewInt(1 << 2)
)

type EntityEvent struct {
	EventType *EntityEventEventType `json:"eventType,omitempty" url:"eventType,omitempty"`
	Time      *time.Time            `json:"time,omitempty" url:"time,omitempty"`
	Entity    *Entity               `json:"entity,omitempty" url:"entity,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityEvent) GetEventType() *EntityEventEventType {
	if e == nil {
		return nil
	}
	return e.EventType
}

func (e *EntityEvent) GetTime() *time.Time {
	if e == nil {
		return nil
	}
	return e.Time
}

func (e *EntityEvent) GetEntity() *Entity {
	if e == nil {
		return nil
	}
	return e.Entity
}

func (e *EntityEvent) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityEvent) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEventType sets the EventType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityEvent) SetEventType(eventType *EntityEventEventType) {
	e.EventType = eventType
	e.require(entityEventFieldEventType)
}

// SetTime sets the Time field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityEvent) SetTime(time *time.Time) {
	e.Time = time
	e.require(entityEventFieldTime)
}

// SetEntity sets the Entity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityEvent) SetEntity(entity *Entity) {
	e.Entity = entity
	e.require(entityEventFieldEntity)
}

func (e *EntityEvent) UnmarshalJSON(data []byte) error {
	type embed EntityEvent
	var unmarshaler = struct {
		embed
		Time *internal.DateTime `json:"time,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityEvent(unmarshaler.embed)
	e.Time = unmarshaler.Time.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityEvent) MarshalJSON() ([]byte, error) {
	type embed EntityEvent
	var marshaler = struct {
		embed
		Time *internal.DateTime `json:"time,omitempty"`
	}{
		embed: embed(*e),
		Time:  internal.NewOptionalDateTime(e.Time),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityEvent) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityEventEventType string

const (
	EntityEventEventTypeEventTypeInvalid            EntityEventEventType = "EVENT_TYPE_INVALID"
	EntityEventEventTypeEventTypeCreated            EntityEventEventType = "EVENT_TYPE_CREATED"
	EntityEventEventTypeEventTypeUpdate             EntityEventEventType = "EVENT_TYPE_UPDATE"
	EntityEventEventTypeEventTypeDeleted            EntityEventEventType = "EVENT_TYPE_DELETED"
	EntityEventEventTypeEventTypePreexisting        EntityEventEventType = "EVENT_TYPE_PREEXISTING"
	EntityEventEventTypeEventTypePostExpiryOverride EntityEventEventType = "EVENT_TYPE_POST_EXPIRY_OVERRIDE"
)

func NewEntityEventEventTypeFromString(s string) (EntityEventEventType, error) {
	switch s {
	case "EVENT_TYPE_INVALID":
		return EntityEventEventTypeEventTypeInvalid, nil
	case "EVENT_TYPE_CREATED":
		return EntityEventEventTypeEventTypeCreated, nil
	case "EVENT_TYPE_UPDATE":
		return EntityEventEventTypeEventTypeUpdate, nil
	case "EVENT_TYPE_DELETED":
		return EntityEventEventTypeEventTypeDeleted, nil
	case "EVENT_TYPE_PREEXISTING":
		return EntityEventEventTypeEventTypePreexisting, nil
	case "EVENT_TYPE_POST_EXPIRY_OVERRIDE":
		return EntityEventEventTypeEventTypePostExpiryOverride, nil
	}
	var t EntityEventEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityEventEventType) Ptr() *EntityEventEventType {
	return &e
}

var (
	entityEventResponseFieldSessionToken = big.NewInt(1 << 0)
	entityEventResponseFieldEntityEvents = big.NewInt(1 << 1)
)

type EntityEventResponse struct {
	// Long-poll session identifier. Use this token to resume polling on subsequent requests.
	SessionToken *string        `json:"sessionToken,omitempty" url:"sessionToken,omitempty"`
	EntityEvents []*EntityEvent `json:"entityEvents,omitempty" url:"entityEvents,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityEventResponse) GetSessionToken() *string {
	if e == nil {
		return nil
	}
	return e.SessionToken
}

func (e *EntityEventResponse) GetEntityEvents() []*EntityEvent {
	if e == nil {
		return nil
	}
	return e.EntityEvents
}

func (e *EntityEventResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityEventResponse) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetSessionToken sets the SessionToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityEventResponse) SetSessionToken(sessionToken *string) {
	e.SessionToken = sessionToken
	e.require(entityEventResponseFieldSessionToken)
}

// SetEntityEvents sets the EntityEvents field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityEventResponse) SetEntityEvents(entityEvents []*EntityEvent) {
	e.EntityEvents = entityEvents
	e.require(entityEventResponseFieldEntityEvents)
}

func (e *EntityEventResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityEventResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityEventResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityEventResponse) MarshalJSON() ([]byte, error) {
	type embed EntityEventResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityEventResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	entityStreamEventFieldEventType = big.NewInt(1 << 0)
	entityStreamEventFieldTime      = big.NewInt(1 << 1)
	entityStreamEventFieldEntity    = big.NewInt(1 << 2)
)

type EntityStreamEvent struct {
	EventType *EntityEventEventType `json:"eventType,omitempty" url:"eventType,omitempty"`
	Time      *time.Time            `json:"time,omitempty" url:"time,omitempty"`
	Entity    *Entity               `json:"entity,omitempty" url:"entity,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityStreamEvent) GetEventType() *EntityEventEventType {
	if e == nil {
		return nil
	}
	return e.EventType
}

func (e *EntityStreamEvent) GetTime() *time.Time {
	if e == nil {
		return nil
	}
	return e.Time
}

func (e *EntityStreamEvent) GetEntity() *Entity {
	if e == nil {
		return nil
	}
	return e.Entity
}

func (e *EntityStreamEvent) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityStreamEvent) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEventType sets the EventType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityStreamEvent) SetEventType(eventType *EntityEventEventType) {
	e.EventType = eventType
	e.require(entityStreamEventFieldEventType)
}

// SetTime sets the Time field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityStreamEvent) SetTime(time *time.Time) {
	e.Time = time
	e.require(entityStreamEventFieldTime)
}

// SetEntity sets the Entity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityStreamEvent) SetEntity(entity *Entity) {
	e.Entity = entity
	e.require(entityStreamEventFieldEntity)
}

func (e *EntityStreamEvent) UnmarshalJSON(data []byte) error {
	type embed EntityStreamEvent
	var unmarshaler = struct {
		embed
		Time *internal.DateTime `json:"time,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityStreamEvent(unmarshaler.embed)
	e.Time = unmarshaler.Time.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityStreamEvent) MarshalJSON() ([]byte, error) {
	type embed EntityStreamEvent
	var marshaler = struct {
		embed
		Time *internal.DateTime `json:"time,omitempty"`
	}{
		embed: embed(*e),
		Time:  internal.NewOptionalDateTime(e.Time),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityStreamEvent) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	entityStreamHeartbeatFieldTimestamp = big.NewInt(1 << 0)
)

type EntityStreamHeartbeat struct {
	// timestamp of the heartbeat
	Timestamp *time.Time `json:"timestamp,omitempty" url:"timestamp,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityStreamHeartbeat) GetTimestamp() *time.Time {
	if e == nil {
		return nil
	}
	return e.Timestamp
}

func (e *EntityStreamHeartbeat) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityStreamHeartbeat) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityStreamHeartbeat) SetTimestamp(timestamp *time.Time) {
	e.Timestamp = timestamp
	e.require(entityStreamHeartbeatFieldTimestamp)
}

func (e *EntityStreamHeartbeat) UnmarshalJSON(data []byte) error {
	type embed EntityStreamHeartbeat
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityStreamHeartbeat(unmarshaler.embed)
	e.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityStreamHeartbeat) MarshalJSON() ([]byte, error) {
	type embed EntityStreamHeartbeat
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*e),
		Timestamp: internal.NewOptionalDateTime(e.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityStreamHeartbeat) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	heartbeatObjectFieldTimestamp = big.NewInt(1 << 0)
)

type HeartbeatObject struct {
	// timestamp of the heartbeat
	Timestamp *time.Time `json:"timestamp,omitempty" url:"timestamp,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HeartbeatObject) GetTimestamp() *time.Time {
	if h == nil {
		return nil
	}
	return h.Timestamp
}

func (h *HeartbeatObject) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HeartbeatObject) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartbeatObject) SetTimestamp(timestamp *time.Time) {
	h.Timestamp = timestamp
	h.require(heartbeatObjectFieldTimestamp)
}

func (h *HeartbeatObject) UnmarshalJSON(data []byte) error {
	type embed HeartbeatObject
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = HeartbeatObject(unmarshaler.embed)
	h.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HeartbeatObject) MarshalJSON() ([]byte, error) {
	type embed HeartbeatObject
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*h),
		Timestamp: internal.NewOptionalDateTime(h.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HeartbeatObject) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The stream event response.
type StreamEntitiesResponse struct {
	Event     string
	Heartbeat *EntityStreamHeartbeat
	Entity    *EntityStreamEvent
}

func (s *StreamEntitiesResponse) GetEvent() string {
	if s == nil {
		return ""
	}
	return s.Event
}

func (s *StreamEntitiesResponse) GetHeartbeat() *EntityStreamHeartbeat {
	if s == nil {
		return nil
	}
	return s.Heartbeat
}

func (s *StreamEntitiesResponse) GetEntity() *EntityStreamEvent {
	if s == nil {
		return nil
	}
	return s.Entity
}

func (s *StreamEntitiesResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Event string `json:"event"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Event = unmarshaler.Event
	if unmarshaler.Event == "" {
		return fmt.Errorf("%T did not include discriminant event", s)
	}
	switch unmarshaler.Event {
	case "heartbeat":
		value := new(EntityStreamHeartbeat)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Heartbeat = value
	case "entity":
		value := new(EntityStreamEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Entity = value
	}
	return nil
}

func (s StreamEntitiesResponse) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Heartbeat != nil {
		return internal.MarshalJSONWithExtraProperty(s.Heartbeat, "event", "heartbeat")
	}
	if s.Entity != nil {
		return internal.MarshalJSONWithExtraProperty(s.Entity, "event", "entity")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type StreamEntitiesResponseVisitor interface {
	VisitHeartbeat(*EntityStreamHeartbeat) error
	VisitEntity(*EntityStreamEvent) error
}

func (s *StreamEntitiesResponse) Accept(visitor StreamEntitiesResponseVisitor) error {
	if s.Heartbeat != nil {
		return visitor.VisitHeartbeat(s.Heartbeat)
	}
	if s.Entity != nil {
		return visitor.VisitEntity(s.Entity)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *StreamEntitiesResponse) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Heartbeat != nil {
		fields = append(fields, "heartbeat")
	}
	if s.Entity != nil {
		fields = append(fields, "entity")
	}
	if len(fields) == 0 {
		if s.Event != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Event)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Event != "" {
		field := fields[0]
		if s.Event != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Event,
				s,
			)
		}
	}
	return nil
}
